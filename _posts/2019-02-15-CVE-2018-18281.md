---
title: TLB 缓存延迟刷新漏洞解析
subtitle: CVE-2018-18281 漏洞原理与利用
author: jiayy
data: 2019-02-15
---

# TLB 缓存延迟刷新漏洞

## 简介

[CVE-2018-18281](https://bugs.chromium.org/p/project-zero/issues/detail?id=1695) 是一个 linux kernel 的漏洞, 是由谷歌 project zero 的 [Jann Horn](https://twitter.com/tehjh) 发现的, 这个漏洞的模式比较罕见, 不同于常规的内存溢出类漏洞, 也不是常见的 UAF 漏洞, 它是由内存管理系统的底层逻辑错误导致的, 根本原因是 TLB 缓存没有及时刷新造成虚拟地址复用, 可以实现较为稳定的提权利用. Jann Horn 在上个月放出了漏洞细节 [Taking a page from the kernel's book: A TLB issue in mremap](https://googleprojectzero.blogspot.com/2019/01/taking-page-from-kernels-book-tlb-issue.html), 我学习之后写了这篇文章, 用于国内研究人员交流学习.

## TLB

linux内核通过 [多级页表](https://en.wikipedia.org/wiki/Page_table) 实现虚拟内存机制, 为了提高访问速度, 一些页表项会被缓存在 [TLB](https://en.wikipedia.org/wiki/Translation_lookaside_buffer) 里, 指令在访问一个虚拟地址的时候, 会先查找 TLB , 如果没有命中, 才去遍历主存里的多级页表, 并将查找到的 (虚拟内存-物理内存) 映射填入 TLB

反过来, 如果某个 (虚拟内存-物理内存) 映射关系要解除, 除了在主存里的相关表项要删除, 还需要对多个cpu core 同步执行 TLB 刷新,使得在所有 TLB 缓存里该映射关系消除, 否则就会出现不一致. 

上述关于 TLB 和内存映射的说明只是简化版本, 用于简单理解这个漏洞的原因, 真正的实现不同操作系统, 不同体系架构, 都不一样. 可以查阅芯片手册, 如 [TLBs, Paging-Structure Caches, and Their Invalidation](http://kib.kiev.ua/x86docs/SDMs/317080-002.pdf)  和一些分析, 如 [Reverse Engineering Hardware Page Table Caches](https://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf)


## 漏洞

- [mremap](http://man7.org/linux/man-pages/man2/mremap.2.html) 系统调用用来改变虚拟内存的映射区域
- [ftruncate](https://linux.die.net/man/2/ftruncate) 系统调用用来改变文件的大小到指定大小

这两个系统调用表面上看八竿子打不着, 但在 linux 内核的实现里, 他们的调用链条会出现一个竞态条件异常

```bash
1) sys_mremap() -> mremap_to()->move_vma()->move_page_tables(). 
move_page_tables() first calls move_ptes() in a loop, 
then performs a TLB flush with flush_tlb_range().

2) sys_ftruncate()->do_sys_ftruncate()->do_truncate()->notify_change()
->shmem_setattr()->unmap_mapping_range()->unmap_mapping_pages()
->unmap_mapping_range_tree()->unmap_mapping_range_vma()
->zap_page_range_single() can concurrently access the page tables of a
process that is in move_page_tables(), between the move_ptes() loop
and the TLB flush.
```

假设一个进程有 A,B,C 三个线程:

- 1) A 映射一个文件 a 到地址 X, 映射条件为: PROT_READ | MAP_SHARED
- 2) C 循环读取 X 的内容
- 3) A 调用 mremap 重新映射 X 到 Y, 这个调用会执行下面两个函数:
	- 3.1) move_ptes , 该函数做如下操作:
		- 3.1.1) 获取 X 页表和 Y 页表的锁
		- 3.1.2) 遍历 X 页表的 pte , 释放之, 并在 Y 页表重建这些 pte 
 		- 3.1.3) 释放 Y 页表的锁
 		- 3.1.4) 释放 X 页表的锁
	- 3.2) flush_tlb_range : 该函数将刷新 X 对应的 TLB 缓存 
- 4) B 调用 ftruncate 将文件 a 的文件大小改为 0, 这个调用会执行下面操作:
	- 4.1) 获取 Y 页表的锁
	- 4.2) 删除地址 Y 的页表
	- 4.3) 刷新 Y 对应的 TLB 缓存

这里存在的竞态条件是当 4.3 已经执行完毕 (3.1.3 释放 Y 锁 4.1 就可以执行), 地址 Y 的内存已经释放, 物理页面已经返回给 [伙伴系统](https://en.wikipedia.org/wiki/Buddy_memory_allocation) , 并再一次分配给新的虚拟内存, 而此时 3.2 还没有执行, 这种情况下, 线程 C 依然可以访问 X 的内存, 造成地址复用

v4.9 之前的内核, move_ptes 的逻辑与上述有些许不同, 在 versions < 4.9 的 linux 内核, Dirty 标记的页面会在 move_ptes 函数内部刷新 TLB , 而不是等到 3.2 由 flush_tlb_range 函数去刷新, 因此, race 发生之后, 线程 C 能通过 X 访问到的内存都是之前 non-Dirty 的页面, 即被写过的页面都无法复用. 这个问题的影响, 我觉得是在写 poc 和 exploit 时, 最开始映射地址 X 后不能写初始值, 但这点可以通过其他方法解决, Jann Horn 在 [writeup](https://googleprojectzero.blogspot.com/2019/01/taking-page-from-kernels-book-tlb-issue.html) 里提到这个问题导致 v4.9 之前的内核只能 use-after-free reads, 而无法 use-after-free writes, 我觉得不对. 因为线程 A 可以用 PROT_WRITE 映射 X 然后不写它, 而是遍历读它, 这样就不是 Dirty 页面, 在 mremap 时不会被 move_ptes 函数 flush TLB, 在 race 触发之后, C 依然可以对复用的地址进行写操作, 因为它们是 PROT_WRITE mmap . 

v4.9 之后的内核都是上述列表显示的代码逻辑.

根据上述分析, 一个简单的 poc 思路就出来了, 通过不断检测线程 C 从地址 X 读取的内容是不是初始内容就可以判断 race 是否被触发, 正常情况下, C 读取 X 只会有两种结果, 一种是 mremap 彻底完成, 即 3.2 执行完毕, 此时地址 X 为无效地址, C 的读操作引发进程奔溃退出, 第二种是 mremap 还未完成, C 读取的地址返回的是 X 的初始内容, 只有这两种情况才符合 mremap 函数的定义. 但是由于漏洞的存在, 实际运行会存在第三种情况, 即 C 读取 X 不会奔溃(3.2 还没执行, 地址映射还有效), 但内容变了( 4.3 执行完毕, 物理页面已经被其他地方复用)

[这份 poc](https://github.com/jiayy/android_vuln_poc-exp/tree/master/CVE-2018-18281) 可以清晰看出 race 是怎么发生的, 需要注意, 这份 poc 必须配合内核补丁才能稳定触发 race , 否则命中率非常低, 补丁通过在 move_page_tables 函数调用 flush_tlb_range 之前(即 3.2 之前)增加一个大循环来增大 race 条件的时间窗口以提高命中率

## 利用思路

上述 poc 的运行结果是, 大部分情况下 poc 奔溃退出, 少数情况下读取 X 会返回一个被其他地方复用的页面, 这离稳定提权还有很远的距离, 为了得到稳定利用, 至少有两个问题需要解决:

- 如何提高 race 的命中率
- 选择什么样的地址复用场景(怎么实现提权)

##  如何提高 race 的命中率

要提高本漏洞 race 的命中率, 就是要增大 move_ptes 函数和 flush_tlb_range 函数之间的时间间隔

```bash
怎么才能增加这俩函数执行的时间间隔呢?
```

这里要引入linux内核的 [进程抢占](https://en.wikipedia.org/wiki/Linux_kernel#PREEMPTION) 概念, 如果目标内核是可抢占的 (CONFIG_PREEMPT=y) , 则如果能让进程在执行 flush_tlb_range 函数之前被抢占, 那么 race 的时间窗口就够大了, 用户空间的普通程序能不能触发某个进程被调度呢? 答案是肯定的.

用户空间有两个系统函数可以影响进程的调度

- [sched_setaffinity](http://man7.org/linux/man-pages/man2/sched_setaffinity.2.html) 函数用来绑定进程到某个 cpu core
- [sched_setscheduler](http://man7.org/linux/man-pages/man2/sched_setscheduler.2.html) 函数用来设置进程的调度策略和调度参数

使用这两个函数将 poc 修改为下面的方案,

新建 A,B,C,D 四个线程:

- 1) A 映射一个文件 a 到地址 X, A 绑定到核 c1, A 调度策略设置为 SCHED_IDLE 
- 2) C 绑定到核 c1, C 阻塞在某个 pipe, pipe 返回则调用 ftruncate 将文件 a 的文件大小改为 0
- 3) A 调用 mremap 重新映射 X 到 Y, 这将执行下面两个函数:
	- 3.1) move_ptes
	- 3.2) flush_tlb_range
- 4) D 绑定到核 c2, 监控进程的内存映射情况,如果发生变化则通过写 pipe 唤醒 C
- 5) B 绑定到核 c3, 循环读取 X 的内容, 并判断是否还是初始值

通过上述方案可以理论上让线程 A 在执行 3.1 后, 执行 3.2 前被挂起, 从而扩大 3.1 和 3.2 的时间间隔 

```bash
mremap 执行 move_ptes 函数会引发内存状态变化, 这种变化可以通过用户态文件 /proc/pid/status 文件获取, 这就是线程 D 的作用
```
此时, 通过监控线程 D 唤醒 C, 由于A 和 C 绑定在同一个核心, 且 A 的调度策略被设置为最低优先级 SCHED_IDLE, C 的唤醒将抢占 A 的执行, 如此一来, 3.2 的执行就可能被延迟. C 被唤醒后立即执行 ftruncate 释放 Y 的内存触发漏洞.

我根据上述思路改写了 [这个 poc](https://github.com/jiayy/android_vuln_poc-exp/blob/master/CVE-2018-18281-Android/poc.old.c) , 实测发现触发率还是很低, 但稍微修改一下就可以得到不错的命中率

改进版方案: 新建 A,B,C,D,E 五个线程:

- 1) A 映射一个文件 a 到地址 X, A 绑定到核 c1, A 调度策略设置为 SCHED_IDLE 
- 2) C 绑定到核 c1, C 阻塞在某个 pipe, pipe 返回则立即将 A 重新绑定到核 c4, 
     并调用 ftruncate 将文件 a 的文件大小改为 0
- 3) A 调用 mremap 重新映射 X 到 Y
	- 3.1) move_ptes
	- 3.2) flush_tlb_range
- 4) D 绑定到核 c2, 监控进程的内存映射情况,如果发生变化则通过写 pipe 唤醒 C
- 5) B 绑定到核 c3, 循环读取 X 的内容, 并判断是否还是初始值
- 6) E 绑定到核 c4, 执行一个死循环.

[改进版 poc 代码](https://github.com/jiayy/android_vuln_poc-exp/blob/master/CVE-2018-18281-Android/poc.c), 个人判断命中率提升的原因是由于当 C 的管道返回后手动执行重绑定 A 到新的核 c4 可能会导致 A 立即被挂起. 

利用这个 poc, 我们可以将这个漏洞的 race 命中率提升到可以接受的程度.


## 选择什么样的地址复用场景(怎么实现提权)

现在我们可以在比较短的时间内稳定触发漏洞, 得到一片已经被释放的物理页面的使用权,而且可读可写,怎么利用这一点来提权?

我们需要知道页面被释放之后去了哪里,重新分配的时候被哪些地方使用.

(待补充)


## 通过改写文件 page cache 提权

linux 上硬盘文件的内容在内核用 page cache 来维护, 如果漏洞触发后释放的页面被用于某个文件的 page cache, 则我们拥有了读写该文件的能力, 如果这个文件恰好是用户态的重要动态库文件, 比如 /system/lib64/libandroid_runtime.so(android系统的运行时), 正常情况下普通进程无法改写这个文件, 但通过漏洞普通进程可以改写它, 这样就可以用来提权.

上述利用思路的关键有两点:

- 选择目标文件要改写的位置
- 提高目标位置所在页面的命中率

以 libandroid_runtime.so 为例, 目标位置必须是代码区, 最好是一个函数, 而且该函数的代码初始位置是页面对齐的, 这样目标位置可以以页面为单位加载进内存, 或者以页面为单位置换到硬盘, 这个函数必须被某个高权限进程在某种时机下调用, 而且这种时机必须可以由普通进程触发

```bash
"com_android_internal_os_Zygote_nativeForkAndSpecialize" 函数就是符合条件的函数
```

- 这个函数被 zygote 调用, zygote 进程是一个特权进程
- 这个函数在 libandroid_runtime.so (pixel2 PQ1A.181105.017.A1) 文件的偏移是 0x157000, 这个偏移是页面对齐的
- 这个函数一般情况下不会被调用, 只有启动新的app时会被 zygote 调用

```bash
adb pull /system/lib64/libandroid_runtime.so

root@jiayy:CVE-2018-18281# xxd -s 0x157000 -l 100 libandroid_runtime.so 
00157000: 0871 0091 5f00 08eb c000 0054 e087 41a9  .q.._......T..A.
00157010: e303 1f32 0800 40f9 0801 43f9 0001 3fd6  ...2..@...C...?.
00157020: 2817 40f9 a983 5af8 1f01 09eb e110 0054  (.@...Z........T
00157030: ff03 1191 fd7b 45a9 f44f 44a9 f657 43a9  .....{E..OD..WC.
00157040: f85f 42a9 fa67 41a9 fc6f c6a8 c003 5fd6  ._B..gA..o...._.
00157050: f801 00b0 d901 00b0 ba01 00f0 7b02 00f0  ............{...
00157060: 9c01 0090  
```

因此, 通过漏洞触发 race 后, 释放的物理页面如果能刚好被 0x157000 这个文件偏移用于 page cache, 则可以改写 com_android_internal_os_Zygote_nativeForkAndSpecialize 函数的代码逻辑, 并触发 zygote 去执行新的逻辑(shellcode)

## 如何提高文件 page cache 命中率
<span id="raise_pagecache_hit"></span>

[这篇论文](https://arxiv.org/pdf/1710.00551.pdf) 的 section VIII-B 介绍了一种算法用于精确控制一个file page cache的加载 

- 1) 打开一个大文件a, mmap 到内存 
- 2) 打开目标文件b, mmap 到内存
- 3) 在一个循环内, 执行: 
	- 3.1) 按照 pagesize 逐页面读取a的内容
     	    这会导致内核申请大量 page cache 来装载文件 a, 
	    从而迫使其他文件的 page cache 被置换到硬盘
	- 3.2) 判断目标页面X是否在内存里, 如果不是, 跳转到 4.1
- 4) 在一个循环内, 执行:
	- 4.1) 按照 pagesize 逐页面读取b的内容, 但遇到目标页面X则跳过
     	       这会导致目标文件除目标页面X之外其他页面被重新装载会内存
	- 4.2) 判断目标页面X是否在内存里, 如果是, 跳转到 3.1
- 5) 如果读取完全部 b 的内容, 目标页面 X 仍然没有在内存里, 结束.

通过上述算法, 可以让一个目标文件的目标页面X被置换到硬盘, 而其他页面保留在内存里, 这样在漏洞触发之后, 再来访问目标页面, 则很大机会会分配刚刚释放的物理页面给目标页面, 是否命中可以通过模式匹配来判断

## exploit code

我改了一份exploit 代码 [在这里](https://github.com/jiayy/android_vuln_poc-exp/tree/master/EXP-CVE-2018-18281), 主要包含下面几个文件:

- compile.sh
- shellcode.s
- exp.c
- watchdog.c

### compile.sh

这是编译脚本

```bash
1) aarch64-linux-gnu-as arm_shellcode.s -o arm_shellcode.o  
2) aarch64-linux-gnu-ld arm_shellcode.o -o arm_shellcode 
3) aarch64-linux-gnu-objcopy --dump-section .text=arm_shellcode.bin arm_shellcode 
4) xxd -i arm_shellcode.bin > arm_shellcode.h 
5) make
```
1~3 是将汇编文件 arm_shellcode.s 编译成二进制并将可执行文件的代码段 (.text) 提取到文件 arm_shellcode.bin 

4 使用 linux 的 xxd 工具将 arm_shellcode.bin 放进一个 c 语言分格的数组，后续在 c 代码里以数组变量的形式操作它

5 根据 Android.mk 编译可执行文件


## shellcode.s 

- shellcode.s 本身很简单: 读取文件 “/proc/self/attr/current” ，然后将读取的内容作为参数调用 sethostname 函数，从而更改系统的 hostname

- 因为普通 app 没有权限调用系统函数 'sethostname', 本 exploit 通过注入 shellcode.s 到 libandroid_runtime.so, 然后触发 zygote 进程执行 shellcode.s 达到越权执行的目的

下面简单看一下 shellcode.s 汇编,不感兴趣可以略过

```c
// open file
_start:
mov x0, #-100
adrp x1, _start
// NOTE: We are changing the page-relative alignment of the shellcode, so normal
// aarch64 RIP-relative addressing doesn't work.
add x1, x1, attr_path-file_start
mov x2, #0
mov x8, #0x38
svc #0

attr_path:
.ascii "/proc/self/attr/current\0"
```

第一段汇编作用是 open 文件 "/proc/self/attr/current", #0x38 是系统调用号，对应系统调用 __NR_openat (系统调用号定义： include/uapi/asm-generic/unistd.h), 将 0x38 放入 x8 寄存器，svc #0 指令触发软中断，进入内核系统调用, 根据 openat 函数的定义, x1 寄存器存放要打开的文件路径的地址, x0 和 x2 这里忽略.

这段汇编执行后，x0寄存器存放返回值，即打开文件的 fd


```c
// read from file
sub sp, sp, #128
mov x1, sp
mov x2, #128
mov x8, #0x3f
svc #0
```

第二段汇编执行 read 系统调用，读取 128 字节放入栈, #0x3f 对应系统调用 read, x0 存放要读取文件的 fd, x1 是栈顶指针 sp, 在此之前，sp 被移动了#128 字节，相当于一个 128 字节的栈数组作为 buf传给 read 函数第二个参数, x2 是要读取的长度, 这里是 128

这段汇编执行后, sp 指向的位置存放文件 '/proc/self/attr/current' 的内容


```c
// shove file contents into hostname
mov x1, x0
mov x0, sp
mov x8, #0xa1
svc #0
```
第三段汇编执行 sethostname 系统调用, #0xa1 对应系统调用 sethostname, x0 即要更新的域名字符串, 这里放入 sp 指针， 即将上一步 read 函数读取的 buf 值作为 sethostname 的参数 name, x1 是长度, 这里值是上一步read 的返回值

这段汇编执行后, hostname 将被更新为文件 '/proc/self/attr/current' 的内容

## watchdog.c 

这个文件的作用是不断调用 exp 可执行文件并监控 exploit 是否成功, 之所以需要这个主调程序是由于这个漏洞在触发的时候, 大部分情况会引发程序奔溃, 这时候需要一个看门狗程序不断重启它

## exp.c

这个文件实现了exploit的主体功能

- kickout_victim_page 函数
- idle_worker 线程
- spinner 线程
- nicer_spinner 线程
- read_worker 线程
- segv_handler 函数

kickout_victim_page 函数实现了 [如何提高文件 page cache 命中率](#raise_pagecache_hit) 的算法

idle_worker 线程用于触发 mremap 调用

spinner 线程用于触发 fallocate (跟 ftruncate 效果类似) 调用, 制造与 idle_worker 线程的 race

nicer_spinner 线程与 idle_worker 绑定在同一个核, 用于抢占 idle_worker  的 cpu 使用权

read_worker 线程用于监控目标内存, 一旦发现 race 成功触发, 则注入 shellcode 到目标内存

segv_handler 函数是段错误处理函数, 这里会再一次检测 shellcode 是否已经成功注入到目标文件, 如果是, 则通知 watchdog 停止重启 exp


## 引用

 - [mremap TLB flush too late with concurrent ftruncate](https://bugs.chromium.org/p/project-zero/issues/detail?id=1695)
 - [the patch](https://lkml.org/lkml/2018/11/2/423)
 - [Taking a page from the kernel's book: A TLB issue in mremap](https://googleprojectzero.blogspot.com/2019/01/taking-page-from-kernels-book-tlb-issue.html)
